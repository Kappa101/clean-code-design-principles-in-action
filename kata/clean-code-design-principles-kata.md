# ABSTRACT
Most developers agree that "Software must be Well-Designed". 

But what is a "Good" Design? 

This workshop presents a core set of Design Principles that will help you make your application easier to implement, change and understand. 

Starting from a focused but realistic specification, we will practice with a Kata where each step introduces a challenge that can be solved by applying different Principles & Patterns.



# TRAINING OBJECTIVES
Through the workshop you will learn to:
* understand the basic dynamics of a complex Software system, and key Design concepts such as Cohesion, Coupling, Abstraction and Impact of Change.
* apply core Design Principles to improve the structure of your applications
* balance the pros & cons of alternative Design choices



# TABLE OF CONTENTS
* What is Software Design? what is a "good" Design?
* Why is it important?
* Key ideas from Event Storming & Domain Driven Design
* Key forces in Software Design

* The Travel Expenses Kata



# TOPICS 
* Single Responsibility Principle for methods
* Single Responsibility Principle for Classes
* Single Responsibility means splitting …
* How to start?



# TOPICS
* Reviewing your Design
* Collaborating with other classes
* Generalizing the model
* Incremental development and Evolutionary Design
* How to continue by yourself: references for further learning



# TRAINING OBJECTIVES
Through the workshop you will learn to:
* understand the basic dynamics of a complex Software system, and key Design concepts such as Cohesion, Coupling, Abstraction and Impact of Change.
* apply core Design Principles to improve the structure of your applications
* balance the pros & cons of alternative Design choices



# WHO THE WORKSHOP IS DEDICATED TO?
Basically, to all developers! Independently from the language / platform you are developing on, this workshop is for you if:
* you are moving from implementing a detailed specification to designing new features and application
* you are interested in improving your Software Design approach and skills
* you want to develop more robust and maintainable applications with more productivity



# PREREQUISITES
* Working knowledge and practical experience in one programming language (you should be able to write/compile/test/debug by yourself a program which reads and parses input and presents output either on the command line or in a simple GUI).
* Good knowledge of Object Oriented concepts (Class, Interface, Method, Variable Scope and Visibility) and ability to "read" them from a sketch/diagram
* Basic knowledge of HTTP



# HARDWARE AND SOFTWARE REQUIREMENTS
* Laptop
* Web Browser (Chrome or Firefox)
* Text Editor (Sublime, Atom, Visual Studio Code,…)
* IDE (Eclipse, NetBeans, Intellij, Visual Studio,.. )
* Pen and Paper



# What is Software Design? 

# what is a "good" Design?



# TOPICS 
* What is Software Design? 
* what is a "good" Design?

* up-front vs continuous design
* Design vs Agile
* Evolutionary vs Emergent Design
* Modeling vs Design



# Why is it important?
* the two bottlenecks of Software Development: learning and communication
* Essential vs Accidental Complexity



# Key ideas from Event Storming & Domain Driven Design



# TOPICS
Key ideas from Event Storming & Domain Driven Design
* Ubiquitous Language
* focus on the Domain
* "Big Picture" vs local consistency (Bounded Contexts)



# Key forces in Software Design



# TOPICS 
Key forces in Software Design
* Cohesion
* Coupling
* Impact of Change
* fragile vs robust designs



# The Travel Expenses Kata



# TOPICS 
The Travel Expenses Kata
* what is a Kata?
* overview of the Kata
* basic requirements



# Single Responsibility Principle for methods



# TOPICS
Single Responsibility Principle for methods
* Primitives vs orchestrators
* if you have to do 3 things, make 4 functions
* Steps vs Flow



# LAB: Parsing the Expenses Reimbursement Request



# Single Responsibility Principle for Classes



# TOPICS 
Single Responsibility Principle for Classes
What is a Responsibility
* reason to change
* what if…
* looks similar vs changes for the same reason



# LAB: Validating the overall monthly total amount



# Single Responsibility means splitting ...



# TOPICS Single Responsibility means splitting ...
* UI from logic
* Logic from persistence
* I/O from logic
* Sync from Async
* Intent from implementation



# LAB: Generating the Validation Report



# How to start?
* Separation of Concerns in practice: ask yourself questions!
* make it smaller
* top down vs bottom up
* mock steps vs Walking Skeleton



# LAB: Validating Expense limits per category



# TOPICS 
Reviewing your Design
* naming
* model out loud
* validate with examples
* what if this changes?
* the Open / Closed Principle




# LAB: Validating Monthly constraints per category




# TOPICS 
Collaborating with other classes
* Prefer Composition to Inheritance
* Dependency Injection



# LAB: Validating Expense limits per day



# TOPICS 
Generalizing the model
* making the implicit explicit
* Levels of abstraction vs Levels of implementation
* breakthroughs
* Emergent Design



# LAB: Making Validation Rules configurable



# TOPICS 
Incremental development and Evolutionary Design
* the need for a continuous chain of small, safe steps of design &
* how to do everything incrementally
* incremental implementation: in-application Mocks & the Walking Skeleton approach
* the Expand and Contract pattern



# REFERENCES 



# How to continue by yourself: references for further learning
* improving our design
* practice, practice, practice and continuous / daily improvement (Kaizen)
* Principles of Package Design
* More on TDD: Test-friendly vs Well-designed



